# MockMvc

Тестовый фреймворк Spring MVC Test, также известный как MockMvc, обеспечивает
поддержку тестирования приложений Spring MVC. Он выполняет полную обработку
запросов Spring MVC через имитируемые объекты-запросы и объекты-ответов вместо
работающего сервера.

MockMvc можно использовать отдельно для выполнения запросов и проверки ответов.
Его также можно использовать через WebTestClient, где MockMvc подключен в
качестве сервера для обработки запросов. Преимуществом WebTestClient является
возможность работы с объектами более высокого уровня вместо сырых данных, а
также возможность перехода к полноценным, сквозным HTTP-тестам на реальном
сервере с использованием того же API-интерфейса тестирования.

## Описание

Можно писать простые модульные тесты для Spring MVC, создавая экземпляры
контроллера, подключая к нему зависимости и вызывая его методы. Однако такие
тесты не проверяют сопоставления запросов, привязку данных, преобразование
сообщений, преобразование типов, валидацию, а также не задействуют ни один из
вспомогательных методов, аннотированных @InitBinder, @ModelAttribute или
@ExceptionHandler.

Фреймворк Spring MVC Test, также известный как MockMvc, призван обеспечить более
полное тестирование контроллеров Spring MVC без работающего сервера. Он делает
это, вызывая DispatcherServlet и передавая имитируемые реализации API-интерфейса
сервлетов из модуля spring-test, который воспроизводит полную обработку запросов
Spring MVC без работающего сервера.

MockMvc – это тестовый фреймворк на стороне сервера, который позволяет проверять
большинство функциональных возможностей приложения Spring MVC с помощью
облегченных и целевых тестов. Можно использовать его отдельно для выполнения
запросов и проверки ответов, а также можете использовать его через API-интерфейс
WebTestClient с подключенным MockMvc в качестве сервера для обработки запросов.

## Статическое импортирование

При использовании MockMvc непосредственно для выполнения запросов вам необходимо
будет выполнить статическое импортирование:

- MockMvcBuilders.*
- MockMvcRequestBuilders.*
- MockMvcResultMatchers.*
- MockMvcResultHandlers.*

Простой способ запомнить их – осуществлять поиск по MockMvc*.

При использовании MockMvc через WebTestClient вам не понадобится статическое
импортирование. WebTestClient предоставляет текучий (в значении "плавный")
API-интерфейс без статического импортирования.

## Параметры настройки

MockMvc может быть настроен одним из двух способов. Один из них – указать
непосредственно на контроллеры, которые нужно протестировать, и программно
настроить инфраструктуру Spring MVC. Второй – указать на конфигурацию Spring при
использовании фреймворка Spring MVC и инфраструктуры контроллера в нем.

Чтобы настроить MockMvc для тестирования конкретного контроллера, используйте
следующее:

```java
class MyWebTests {
    MockMvc mockMvc;

    @BeforeEach
    void setup() {
        this.mockMvc =
                MockMvcBuilders
                        .standaloneSetup(new AccountController())
                        .build();
    }
    // ...
}
```

Или вы также можете использовать эту настройку при тестировании через
WebTestClient, который делегирует полномочия тому же средству сборки, как это
показано выше.

Чтобы настроить MockMvc через конфигурацию Spring, используйте следующее:

```java

@SpringJUnitWebConfig(locations = "my-servlet-context.xml")
class MyWebTests {
    MockMvc mockMvc;

    @BeforeEach
    void setup(WebApplicationContext wac) {
        this.mockMvc = MockMvcBuilders.webAppContextSetup(this.wac).build();
    }
    // ...
}
```

Или вы также можете использовать эту настройку при тестировании через
WebTestClient который делегирует полномочия тому же средству сборки, как это
показано выше.

Какой вариант настройки следует использовать?

В webAppContextSetup загружается реальная конфигурация Spring MVC, что позволяет
получить более полный интеграционный тест. Поскольку фреймворк TestContext
кэширует загруженную конфигурацию Spring, он помогает осуществлять быстрое
выполнение тестов, даже если вы вводите все больше тестов в свой тестовый
комплект. Более того, можно внедрять имитируемые службы в контроллеры с помощью
конфигурации Spring, чтобы сосредоточиться на тестировании веб-уровня. В
следующем примере имитируемая служба объявлена с помощью Mockito:

```xml

<bean id="accountService" class="org.mockito.Mockito" factory-method="mock">
    <constructor-arg value="org.example.AccountService"/>
</bean>
```

Затем можно внедрить имитируемую службу в тест для настройки и проверки ваших
ожидаемых событий, как показано в следующем примере:

```java
@SpringJUnitWebConfig(locations = "test-servlet-context.xml")
class AccountTests {
    @Autowired
    AccountService accountService;
    MockMvc mockMvc;
    @BeforeEach
    void setup(WebApplicationContext wac) {
        this.mockMvc = MockMvcBuilders.webAppContextSetup(wac).build();
    }
    // ...
}
```